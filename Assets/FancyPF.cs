using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using QPathFinder;

public class FancyPF : MonoBehaviour
{

    public PathFinder pf;

    List<PathQuerry> querries = new List<PathQuerry>();

    struct PathQuerry
    {
        public PathQuerry(int fromNodeID, int toNodeID, float maxHeightDiff, float climbTax, System.Action<List<Node>> callback)
        {
            this.fromNodeID = fromNodeID;
            this.toNodeID = toNodeID;
            this.maxHeightDiff = maxHeightDiff;
            this.climbTax = climbTax;
            this.callback = callback;
        }

        public int fromNodeID;
        public int toNodeID;
        public float maxHeightDiff;
        public float climbTax;
        public System.Action<List<Node>> callback;
    }

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    int c = 0;

    private void FixedUpdate()
    {
        c++;
        c %= 10000;

        if (c % 10 == 0 && !findingPath && querries.Count > 0)
        {
            PathQuerry q = querries[0];
            StartCoroutine(FindShortestPathAsynchonousInternal(q.fromNodeID, q.toNodeID, q.maxHeightDiff, q.climbTax, q.callback));
        }
    }

    public void AddPathQuerry(int fromNodeID, int toNodeID, float maxHeightDiff, float climbTax, System.Action<List<Node>> callback)
    {
        querries.Add(new PathQuerry(fromNodeID, toNodeID, maxHeightDiff, climbTax, callback));
    }

    public int FindNearestNode(Vector3 point, float maxClimbHeight, float climbTax)
    {
        //Debug.Log("maxClimbHeight: " + maxClimbHeight + ", climbTax: " + climbTax);
        float minDistance = float.MaxValue;
        Node nearestNode = null;

        foreach (var node in pf.graphData.nodes)
        {
            float a = ((node.Position.y - point.y) > maxClimbHeight ? 9999 : Mathf.Max(1, (node.Position.y - point.y) * climbTax));
            if (Vector3.Distance(node.Position, point) * a < minDistance)
            {
                minDistance = a * Vector3.Distance(node.Position, point);
                nearestNode = node;
            }
        }

        return nearestNode != null ? nearestNode.autoGeneratedID : -1;
    }

    public void FindShortestPathOfNodes(int fromNodeID, int toNodeID, float maxHeightDiff, float climbTax, System.Action<List<Node>> callback)
    {
        //Debug.Log("maxHeightDiff: " + maxHeightDiff + ", climbTax: " + climbTax);
        if (QPathFinder.Logger.CanLogInfo)
            QPathFinder.Logger.LogInfo(" FindShortestPathAsynchronous triggered from " + fromNodeID + " to " + toNodeID, true);

        AddPathQuerry(fromNodeID, toNodeID, maxHeightDiff, climbTax, callback);
        //StartCoroutine(FindShortestPathAsynchonousInternal(fromNodeID, toNodeID, maxHeightDiff, climbTax, callback));

    }

    bool findingPath = false;

    protected IEnumerator FindShortestPathAsynchonousInternal(int fromNodeID, int toNodeID, float maxHeightDiff, float climbTax, System.Action<List<Node>> callback)
    {
        if (callback == null)
            yield break;

        findingPath = true;

        //Debug.Log("maxHeightDiff: " + maxHeightDiff + ", climbTax: " + climbTax);

        int startPointID = fromNodeID;
        int endPointID = toNodeID;
        bool found = false;

        pf.graphData.ReGenerateIDs();

        Node startPoint = pf.graphData.nodesSorted[startPointID];
        Node endPoint = pf.graphData.nodesSorted[endPointID];

        foreach (var point in pf.graphData.nodes)
        {
            point.heuristicDistance = -1;
            point.previousNode = null;
        }

        List<Node> completedPoints = new List<Node>();
        List<Node> nextPoints = new List<Node>();
        List<Node> finalPath = new List<Node>();

        startPoint.pathDistance = 0;
        startPoint.heuristicDistance = Vector3.Distance(startPoint.Position, endPoint.Position);
        nextPoints.Add(startPoint);

        while (true)
        {
            Node leastCostPoint = null;

            float minCost = 99999;
            foreach (var point in nextPoints)
            {
                if (point.heuristicDistance <= 0)
                {
                    float a = ((-point.Position.y + endPoint.Position.y) > maxHeightDiff ? 999999 : Mathf.Max(1, (-point.Position.y + endPoint.Position.y) * climbTax));
                    float b = ((point.Position.y - startPoint.Position.y) > maxHeightDiff ? 999999 : Mathf.Max(1, (point.Position.y - startPoint.Position.y) * climbTax));
                    point.heuristicDistance = a * Vector3.Distance(point.Position, endPoint.Position) + b * Vector3.Distance(point.Position, startPoint.Position);
                }

                if (minCost > point.combinedHeuristic)
                {
                    leastCostPoint = point;
                    minCost = point.combinedHeuristic;
                }
            }

            if (leastCostPoint == null)
                break;

            if (leastCostPoint == endPoint)
            {
                found = true;
                Node prevPoint = leastCostPoint;
                while (prevPoint != null)
                {
                    finalPath.Insert(0, prevPoint);
                    prevPoint = prevPoint.previousNode;
                }

                if (QPathFinder.Logger.CanLogInfo)
                {
                    if (finalPath != null)
                    {
                        string str = "";
                        foreach (var a in finalPath)
                        {
                            str += "=>" + a.autoGeneratedID.ToString();
                        }
                        QPathFinder.Logger.LogInfo("Path found between " + fromNodeID + " and " + toNodeID + ":" + str, true);
                    }
                }
                callback(finalPath);
                findingPath = true;
                yield break;
            }

            foreach (var path in pf.graphData.paths)
            {
                if (path.IDOfA == leastCostPoint.autoGeneratedID
                || path.IDOfB == leastCostPoint.autoGeneratedID)
                {
                    if (path.isOneWay)
                    {
                        if (leastCostPoint.autoGeneratedID == path.IDOfB)
                            continue;
                    }

                    if (!path.isOpen)
                        continue;

                    Node otherPoint = path.IDOfA == leastCostPoint.autoGeneratedID ?
                                            pf.graphData.nodesSorted[path.IDOfB] : pf.graphData.nodesSorted[path.IDOfA];

                    if (!otherPoint.IsOpen)
                        continue;


                    if (otherPoint.heuristicDistance <= 0)
                    {
                        float a = ((-otherPoint.Position.y + endPoint.Position.y) > maxHeightDiff ? 999999 : Mathf.Max(1, (-otherPoint.Position.y + endPoint.Position.y) * climbTax));
                        float b = ((otherPoint.Position.y - startPoint.Position.y) > maxHeightDiff ? 999999 : Mathf.Max(1, (otherPoint.Position.y - startPoint.Position.y) * climbTax));
                        otherPoint.heuristicDistance = a*Vector3.Distance(otherPoint.Position, endPoint.Position) + b*Vector3.Distance(otherPoint.Position, startPoint.Position);
                    }

                    if (completedPoints.Contains(otherPoint))
                        continue;

                    if (nextPoints.Contains(otherPoint))
                    {
                        if (otherPoint.pathDistance >
                            (leastCostPoint.pathDistance + path.cost))
                        {
                            otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost;
                            otherPoint.previousNode = leastCostPoint;
                        }
                    }
                    else
                    {
                        otherPoint.pathDistance = leastCostPoint.pathDistance + path.cost;
                        otherPoint.previousNode = leastCostPoint;
                        nextPoints.Add(otherPoint);
                    }
                }
            }

            nextPoints.Remove(leastCostPoint);
            completedPoints.Add(leastCostPoint);

            yield return null;
        }

        findingPath = false;

        if (!found)
        {
            if (QPathFinder.Logger.CanLogWarning) QPathFinder.Logger.LogWarning("Path not found between " + fromNodeID + " and " + toNodeID, true);
            callback(null);
            yield break;

        }

        if (QPathFinder.Logger.CanLogError) QPathFinder.Logger.LogError("Unknown error while finding the path!", true);

        callback(null);
        yield break;

    }
}
